<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OmniAvatar ÊµÅÂºèËßÜÈ¢ëÁîüÊàêÂô®</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .input-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .input-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            border: 2px dashed #dee2e6;
            transition: all 0.3s ease;
        }

        .input-card:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
        }

        .input-card h3 {
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .audio-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .record-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .record-btn:hover {
            background: #c82333;
            transform: scale(1.05);
        }

        .record-btn.recording {
            background: #28a745;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .record-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .audio-upload {
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .audio-upload:hover {
            border-color: #4facfe;
            background: #f0f8ff;
        }

        .audio-upload input {
            display: none;
        }

        .image-upload {
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .image-upload:hover {
            border-color: #4facfe;
            background: #f0f8ff;
        }

        .image-upload input {
            display: none;
        }

        .preview-image {
            max-width: 100%;
            max-height: 150px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .generate-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 30px;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 30px;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 172, 254, 0.3);
        }

        .generate-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .video-section {
            background: #000;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .video-player {
            max-width: 100%;
            max-height: 100%;
            border-radius: 10px;
        }

        .streaming-canvas {
            border-radius: 10px;
            display: none;
        }

        /* Ensure videoPlaceholder doesn't affect sizing */
        #videoPlaceholder {
            margin: 0;
            padding: 0;
            line-height: 0;  /* Prevent extra space around img */
        }

        /* Make canvas and placeholder images render identically */
        .streaming-canvas,
        #videoPlaceholder img {
            max-width: 100%;
            max-height: 100%;
            display: block;
            margin: 0 auto;  /* Center horizontally */
        }

        .status {
            text-align: center;
            padding: 20px;
            font-size: 1.1em;
            color: #6c757d;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .success {
            color: #155724;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            width: 0%;
            transition: width 0.3s ease;
        }

        .streaming-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 0.9em;
            z-index: 1000;
        }

        .connection-status.connected {
            background: #28a745;
            color: white;
        }

        .connection-status.disconnected {
            background: #dc3545;
            color: white;
        }

        .audio-controls-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
            min-width: 200px;
        }

        .audio-controls-panel h4 {
            margin: 0 0 10px 0;
            font-size: 1em;
        }

        .audio-control-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .audio-control-btn:hover {
            background: #3a8bfe;
        }

        .audio-control-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .volume-control {
            margin: 10px 0;
        }

        .volume-slider {
            width: 100%;
            margin: 5px 0;
        }

        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ OmniAvatar ÊµÅÂºèËßÜÈ¢ëÁîüÊàêÂô®</h1>
            <p>‰∏ä‰º†ÂõæÁâáÂíåÈü≥È¢ëÔºåÂÆûÊó∂ÁîüÊàêÂêåÊ≠•ÁöÑËØ¥ËØùËßÜÈ¢ë</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <!-- Èü≥È¢ëËæìÂÖ•Âå∫Âüü -->
                <div class="input-card">
                    <h3>üé§ Èü≥È¢ëËæìÂÖ•</h3>
                    <div class="audio-controls">
                        <button id="recordBtn" class="record-btn">
                            <span id="recordIcon">üéôÔ∏è</span>
                            <span id="recordText">ÂºÄÂßãÂΩïÈü≥</span>
                        </button>
                        <div class="audio-upload" onclick="document.getElementById('audioFile').click()">
                            <p>üìÅ ÊàñÁÇπÂáª‰∏ä‰º†Èü≥È¢ëÊñá‰ª∂</p>
                            <p style="font-size: 0.9em; color: #6c757d;">ÊîØÊåÅ WAV, MP3, M4A Ê†ºÂºè</p>
                            <input type="file" id="audioFile" accept="audio/*" onchange="handleAudioUpload(event)">
                        </div>
                    </div>
                    <div id="audioStatus" style="margin-top: 15px; font-size: 0.9em; color: #6c757d;"></div>
                </div>

                <!-- ÂõæÁâáËæìÂÖ•Âå∫Âüü -->
                <div class="input-card">
                    <h3>üñºÔ∏è ÂõæÁâáËæìÂÖ•</h3>
                    <div class="image-upload" onclick="document.getElementById('imageFile').click()">
                        <p>üìÅ ÁÇπÂáª‰∏ä‰º†ÂõæÁâá</p>
                        <p style="font-size: 0.9em; color: #6c757d;">ÊîØÊåÅ JPG, PNG Ê†ºÂºè</p>
                        <input type="file" id="imageFile" accept="image/*" onchange="handleImageUpload(event)">
                        <img id="previewImage" class="preview-image" style="display: none;">
                    </div>
                </div>
            </div>

            <!-- ÁîüÊàêÊåâÈíÆ -->
            <button id="generateBtn" class="generate-btn" onclick="generateVideo()" disabled>
                üöÄ ÂºÄÂßãÊµÅÂºèÁîüÊàê
            </button>

            <!-- ËøõÂ∫¶Êù° -->
            <div id="progressContainer" style="display: none;">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
                <div id="progressText" style="text-align: center; color: #6c757d;">ÂáÜÂ§á‰∏≠...</div>
            </div>

            <!-- Áä∂ÊÄÅÊòæÁ§∫ -->
            <div id="status" class="status"></div>

            <!-- ÈîôËØØ/ÊàêÂäüÊ∂àÊÅØ -->
            <div id="message" style="display: none;"></div>

            <!-- ËßÜÈ¢ëÊí≠ÊîæÂå∫Âüü -->
            <div class="video-section">
                <video id="videoPlayer" class="video-player" controls style="display: none;">
                    ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅËßÜÈ¢ëÊí≠Êîæ
                </video>
                <canvas id="streamingCanvas" class="streaming-canvas"></canvas>
                <div id="videoPlaceholder" style="color: #6c757d; font-size: 1.2em;">
                    üé• ÊµÅÂºèÁîüÊàêÁöÑËßÜÈ¢ëÂ∞ÜÂú®ËøôÈáåÂÆûÊó∂ÊòæÁ§∫
                </div>
                <div id="streamingInfo" class="streaming-info" style="display: none;">
                    <div>üîÑ Ê≠£Âú®ÁîüÊàê...</div>
                    <div id="frameInfo">Â∏ßÊï∞: 0 / 0</div>
                    <div id="chunkInfo">Chunk: 0 / 0</div>
                    <div id="progressInfo">ËøõÂ∫¶: 0%</div>
                    <div id="audioInfo">üîä Èü≥È¢ë: ÂæÖÊí≠Êîæ</div>
                </div>
            </div>
        </div>
    </div>

    <!-- ËøûÊé•Áä∂ÊÄÅÊåáÁ§∫Âô® -->
    <div id="connectionStatus" class="connection-status disconnected">
        üî¥ Êú™ËøûÊé•
    </div>

    <!-- Èü≥È¢ëÊéßÂà∂Èù¢Êùø -->
    <div id="audioControlsPanel" class="audio-controls-panel">
        <h4>üîä Èü≥È¢ëÊéßÂà∂</h4>
        <div>
            <button id="muteBtn" class="audio-control-btn" onclick="toggleMute()">üîá ÈùôÈü≥</button>
            <button id="audioResetBtn" class="audio-control-btn" onclick="resetAudio()">üîÑ ÈáçÁΩÆ</button>
        </div>
        <div class="volume-control">
            <label>Èü≥Èáè:</label>
            <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="50" onchange="updateVolume()">
            <span id="volumeValue">50%</span>
        </div>
        <div id="audioStatus" style="font-size: 0.8em; margin-top: 10px;">Èü≥È¢ëÂ∞±Áª™</div>
    </div>

    <script>
        // ÂÖ®Â±ÄÂèòÈáè
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let audioBlob = null;
        let recordingStartTime = null;
        let imageFile = null;
        let serverUrl = window.location.origin;;
        let socket = null;
        let currentSessionId = null;
        let isGenerating = false;
        let canvas = null;
        let ctx = null;
        let frameQueue = [];
        let isPlaying = false;
        let videoChunks = [];
        let canvasSizeSet = false;  // Track if canvas dimensions are set
        let videoWidth = 720;  // Store actual video width
        let videoHeight = 720;  // Store actual video height
        let currentVideoElement = null;
        let isVideoMode = false;  // Âå∫ÂàÜÊòØÈÄêÂ∏ßÊ®°ÂºèËøòÊòØËßÜÈ¢ëÂùóÊ®°Âºè
        let firstFrameImage = null;  // Store the first frame to display at the end

        let mediaSource = null;
        let sourceBuffer = null;
        let isMSEInitialized = false;
        let isStreamFinished = false;

        // Èü≥È¢ëÊí≠ÊîæÁõ∏ÂÖ≥ÂèòÈáè
        let audioContext = null;
        let audioQueue = [];
        let isAudioPlaying = false;
        let audioStartTime = 0;
        let nextAudioTime = 0;  // Track when the next audio segment should play
        let currentAudioSource = null;
        let audioGainNode = null;
        let isMuted = false;
        let audioVolume = 0.5;

        // Âõ∫ÂÆöpromptÂÄº
        const prompt = "A person speaking naturally with lip sync to the audio";

        // ÂàùÂßãÂåñWebSocketËøûÊé•
        function initializeWebSocket() {
            try {
                // Force polling transport to avoid WebSocket frame size issues with large payloads
                socket = io(serverUrl, {
                    transports: ['polling'],  // Use polling only, no WebSocket upgrade
                    upgrade: false
                });
                
                socket.on('connect', function() {
                    console.log('WebSocketËøûÊé•ÊàêÂäü');
                    console.log('Socket ID:', socket.id);
                    updateConnectionStatus(true);
                });

                socket.on('disconnect', function() {
                    console.log('WebSocketËøûÊé•Êñ≠ÂºÄ');
                    console.log('Socket ID:', socket.id);
                    updateConnectionStatus(false);
                });

                socket.on('connect_error', function(error) {
                    console.error('WebSocketËøûÊé•ÈîôËØØ:', error);
                    updateConnectionStatus(false);
                });
                
                socket.on('video_frame', function(data) {
                    console.log('WebSocket received video_frame event:', data);
                    handleVideoFrame(data);
                });

                socket.on('video_chunk', function(data) {
                    console.log('WebSocket received video_chunk event:', {
                        session_id: data.session_id,
                        chunk_number: data.chunk_number,
                        total_chunks: data.total_chunks,
                        progress: data.progress,
                        video_data_present: !!data.video_data,
                        video_data_length: data.video_data ? data.video_data.length : 0
                    });
                    handleVideoChunk(data);
                });

                socket.on('chunk_start', function(data) {
                    console.log('WebSocket received chunk_start event:', data);
                    handleChunkStart(data);
                });

                socket.on('chunk_complete', function(data) {
                    console.log('WebSocket received chunk_complete event:', data);
                    handleChunkComplete(data);
                });

                socket.on('generation_progress', function(data) {
                    console.log('WebSocket received generation_progress event:', data);
                    updateProgress(data);
                });

                socket.on('generation_complete', function(data) {
                    console.log('WebSocket received generation_complete event:', data);
                    handleGenerationComplete(data);
                });

                socket.on('generation_error', function(data) {
                    console.log('WebSocket received generation_error event:', data);
                    handleGenerationError(data);
                });

                socket.on('start', function(data) {
                    console.log('WebSocket received start event:', data);
                    updateStatus('ËßÜÈ¢ëÁîüÊàêÂ∑≤ÂºÄÂßã...', true);
                });

                socket.on('video_saved', function(data) {
                    console.log('WebSocket received video_saved event:', data);
                    updateStatus(`ËßÜÈ¢ëÂ∑≤‰øùÂ≠òËá≥: ${data.output_path}`, true);
                });

                socket.on('video_save_error', function(data) {
                    console.log('WebSocket received video_save_error event:', data);
                    updateStatus(`ËßÜÈ¢ë‰øùÂ≠òÂ§±Ë¥•: ${data.error}`, false);
                });

                socket.on('streaming_start', function(data) {
                    console.log('WebSocket received streaming_start event:', data);
                    updateStatus('ÂºÄÂßãÊµÅÂºè‰º†ËæìËßÜÈ¢ëÂ∏ß...', true);
                });
                
            } catch (error) {
                console.error('WebSocketÂàùÂßãÂåñÂ§±Ë¥•:', error);
                updateConnectionStatus(false);
            }
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = 'üü¢ Â∑≤ËøûÊé•';
                status.className = 'connection-status connected';
            } else {
                status.textContent = 'üî¥ Êú™ËøûÊé•';
                status.className = 'connection-status disconnected';
            }
        }

        // Â§ÑÁêÜËßÜÈ¢ëÂ∏ßÔºàÈÄêÂ∏ßÊ®°Âºè - ‰∏ªË¶ÅÊ®°ÂºèÔºâ
        function handleVideoFrame(data) {
            console.log('handleVideoFrame called with data:', {
                session_id: data.session_id,
                frame_number: data.frame_number,
                total_frames: data.total_frames,
                chunk_number: data.chunk_number,
                progress: data.progress,
                has_audio: !!data.audio_segment
            });

            if (data.session_id === currentSessionId) {
                console.log('Session ID matches! Processing frame:', data.frame_number, '/', data.total_frames);

                // ËÆæÁΩÆ‰∏∫ÈÄêÂ∏ßÊ®°Âºè
                isVideoMode = false;

                // Â∞ÜÂ∏ßÊ∑ªÂä†Âà∞ÈòüÂàó
                frameQueue.push(data);
                console.log('Frame added to queue. Queue length:', frameQueue.length);

                // Â§ÑÁêÜÈü≥È¢ëÁâáÊÆµ
                if (data.audio_segment) {
                    handleAudioSegment(data);
                }

                // Â¶ÇÊûúËøòÊ≤°ÊúâÂºÄÂßãÊí≠ÊîæÔºåÂºÄÂßãÊí≠Êîæ
                if (!isPlaying) {
                    console.log('Starting streaming playback...');
                    startStreamingPlayback();
                }

                // Êõ¥Êñ∞‰ø°ÊÅØÊòæÁ§∫
                updateStreamingInfo(data);
            } else {
                console.log('Session ID does not match! Ignoring frame.');
            }
        }

        // Â§ÑÁêÜchunkÂÆåÊàê‰∫ã‰ª∂
        function handleChunkComplete(data) {
            if (data.session_id === currentSessionId) {
                console.log(`Á¨¨ ${data.chunk_number + 1} ‰∏™chunkÂÆåÊàêÔºåÂåÖÂê´ ${data.frames_in_chunk} Â∏ß`);
                
                // ÊòæÁ§∫chunkÂÆåÊàêÊ∂àÊÅØ
                updateStatus(`Á¨¨ ${data.chunk_number + 1}/${data.total_chunks} ‰∏™chunkÂÆåÊàê`, true);
                
                // Êõ¥Êñ∞ËøõÂ∫¶‰ø°ÊÅØ
                updateProgress({
                    session_id: data.session_id,
                    progress: data.progress,
                    frames_generated: data.total_frames_generated,
                    total_frames: 150
                });
            }
        }

        // Êñ∞Â¢ûÔºöÂºÄÂßãÈÄöËøáMedia Source ExtensionsÊí≠ÊîæËßÜÈ¢ëÂùó
        function startVideoChunkPlayback() {
            const videoElement = document.getElementById('videoPlayer');
            
            // ÂáÜÂ§áUI
            document.getElementById('streamingCanvas').style.display = 'none';
            document.getElementById('videoPlaceholder').style.display = 'none';
            videoElement.style.display = 'block';
            document.getElementById('streamingInfo').style.display = 'block';

            if (isMSEInitialized) {
                processNextChunk();
                return;
            }

            mediaSource = new MediaSource();
            videoElement.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', () => {
                console.log('MediaSource is open and ready.');
                // ‰øÆÊîπ‰∏∫MP4Ê†ºÂºè‰ª•ÂåπÈÖçÂêéÁ´Ø
                const mimeCodec = 'video/mp4; codecs="avc1.42E01E"'; // H.264 baseline profile
                try {
                    if (MediaSource.isTypeSupported(mimeCodec)) {
                        console.log('MP4 codec is supported');
                        sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
                        sourceBuffer.addEventListener('updateend', processNextChunk);
                        isMSEInitialized = true;
                        processNextChunk(); // Â§ÑÁêÜÈòüÂàó‰∏≠ÁöÑÁ¨¨‰∏Ä‰∏™Âùó
                    } else {
                        console.error('MP4 codec not supported, falling back to frame-by-frame');
                        // ÂõûÈÄÄÂà∞ÈÄêÂ∏ßÊí≠ÊîæÊ®°Âºè
                        fallbackToFrameMode();
                    }
                } catch (e) {
                    console.error('Error creating source buffer:', e);
                    fallbackToFrameMode();
                }
            }, { once: true });
        }

        // Êñ∞Â¢ûÔºöÂõûÈÄÄÂà∞ÈÄêÂ∏ßÊí≠ÊîæÊ®°Âºè
        function fallbackToFrameMode() {
            console.log('Falling back to frame-by-frame playback mode');
            isVideoMode = false;
            
            // Ê∏ÖÁêÜMSEÁõ∏ÂÖ≥ËµÑÊ∫ê
            if (mediaSource) {
                try {
                    if (mediaSource.readyState === 'open') {
                        mediaSource.endOfStream();
                    }
                } catch (e) {
                    console.error('Error ending media source:', e);
                }
            }
            mediaSource = null;
            sourceBuffer = null;
            isMSEInitialized = false;
            
            // ËΩ¨Êç¢ËßÜÈ¢ëÂùó‰∏∫Â∏ßÊï∞ÊçÆ
            convertVideoChunksToFrames();
            
            // ÂêØÂä®CanvasÊí≠Êîæ
            startStreamingPlayback();
        }

        // Êñ∞Â¢ûÔºöÂ∞ÜËßÜÈ¢ëÂùóËΩ¨Êç¢‰∏∫Â∏ßÊï∞ÊçÆÔºàÁî®‰∫éÂõûÈÄÄÊ®°ÂºèÔºâ
        function convertVideoChunksToFrames() {
            // ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂåñÁöÑÂÆûÁé∞ÔºåÂÆûÈôÖ‰∏≠ÂèØËÉΩÈúÄË¶ÅÊõ¥Â§çÊùÇÁöÑËßÜÈ¢ëËß£Á†Å
            // ËøôÈáåÊàë‰ª¨ÂÅáËÆæÊØè‰∏™ËßÜÈ¢ëÂùóÂåÖÂê´Â§öÂ∏ßÔºåÈúÄË¶ÅÊèêÂèñ
            console.log('Converting video chunks to frames for fallback mode');
            
            // Ê∏ÖÁ©∫Â∏ßÈòüÂàó
            frameQueue = [];
            
            // ‰∏∫ÊØè‰∏™ËßÜÈ¢ëÂùóÂàõÂª∫Âç†‰ΩçÂ∏ßÊï∞ÊçÆ
            videoChunks.forEach((chunk, chunkIndex) => {
                // ÂÅáËÆæÊØè‰∏™ÂùóÊúâ3Â∏ßÔºàÊ†πÊçÆ‰Ω†ÁöÑÈÖçÁΩÆÔºâ
                const framesPerChunk = 3;
                for (let frameIndex = 0; frameIndex < framesPerChunk; frameIndex++) {
                    frameQueue.push({
                        session_id: chunk.session_id,
                        frame_number: chunkIndex * framesPerChunk + frameIndex + 1,
                        total_frames: chunk.total_chunks * framesPerChunk,
                        chunk_number: chunkIndex,
                        progress: chunk.progress,
                        frame_data: null, // ËøôÈáåÈúÄË¶Å‰ªéËßÜÈ¢ëÂùó‰∏≠ÊèêÂèñÂ∏ßÊï∞ÊçÆ
                        block_progress: ((frameIndex + 1) / framesPerChunk) * 100
                    });
                }
            });
            
            console.log(`Converted ${videoChunks.length} video chunks to ${frameQueue.length} frames`);
        }

        // Êñ∞Â¢ûÔºöÂ§ÑÁêÜËßÜÈ¢ëÂùóÈòüÂàóÁöÑÊ†∏ÂøÉÂáΩÊï∞
        function processNextChunk() {
            if (!sourceBuffer || sourceBuffer.updating || videoChunks.length === 0) {
                // Â¶ÇÊûúÊµÅÂ∑≤Ê†áËÆ∞‰∏∫ÁªìÊùüÔºåÂπ∂‰∏îÊ≤°ÊúâÂæÖÂ§ÑÁêÜÁöÑÂùóÔºåÂàôÊ≠£ÂºèÁªìÊùüÊµÅ
                if (isStreamFinished && videoChunks.length === 0 && sourceBuffer && !sourceBuffer.updating) {
                    if (mediaSource.readyState === 'open') {
                        try {
                            mediaSource.endOfStream();
                            console.log('Media stream ended successfully.');
                        } catch (e) {
                            console.error('Error ending media stream:', e);
                        }
                    }
                }
                return;
            }

            // ‰ªéÈòüÂàó‰∏≠ÂèñÂá∫‰∏Ä‰∏™Êï∞ÊçÆÂùó
            const chunkData = videoChunks.shift();
            console.log('Processing video chunk:', {
                chunk_number: chunkData.chunk_number,
                total_chunks: chunkData.total_chunks,
                frames_in_chunk: chunkData.frames_in_chunk,
                video_data_length: chunkData.video_data ? chunkData.video_data.length : 'undefined'
            });
            
            // ÂêéÁ´ØËøîÂõûÁöÑËßÜÈ¢ëÂùóÊï∞ÊçÆÂ≠óÊÆµÂêç
            const videoBase64 = chunkData.video_data; 
            
            if (videoBase64) {
                try {
                    // Base64Ëß£Á†Å‰∏∫Uint8Array
                    console.log('Decoding base64 video data...');
                    const binaryString = atob(videoBase64);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    console.log(`Decoded ${bytes.length} bytes, appending to source buffer...`);
                    
                    // ËøΩÂä†Âà∞ÁºìÂÜ≤Âå∫
                    sourceBuffer.appendBuffer(bytes);
                    
                    // Êõ¥Êñ∞ËøõÂ∫¶‰ø°ÊÅØ
                    updateVideoChunkInfo(chunkData);
                    
                } catch (e) {
                    console.error('Error processing video chunk:', e);
                    console.error('Chunk data:', chunkData);
                    
                    // Â¶ÇÊûúËß£Á†ÅÂ§±Ë¥•ÔºåÂ∞ùËØïÂõûÈÄÄÂà∞ÈÄêÂ∏ßÊ®°Âºè
                    if (videoChunks.length === 0) {
                        console.log('Switching to fallback mode due to decode error');
                        fallbackToFrameMode();
                    }
                }
            } else {
                console.error('No video_data in chunk:', chunkData);
            }
        }

        // Êñ∞Â¢ûÔºöÊõ¥Êñ∞ËßÜÈ¢ëÂùó‰ø°ÊÅØÊòæÁ§∫
        function updateVideoChunkInfo(data) {
            document.getElementById('chunkInfo').textContent = 
                `Chunk: ${data.chunk_number + 1} / ${data.total_chunks}`;
            document.getElementById('progressInfo').textContent = 
                `ËøõÂ∫¶: ${Math.round(data.progress)}%`;
            
            // Êõ¥Êñ∞ËøõÂ∫¶Êù°
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = data.progress + '%';
        }

        // Êñ∞Â¢ûÔºöÂ§ÑÁêÜÈü≥È¢ëÁâáÊÆµ
        function handleAudioSegment(data) {
            if (!data.audio_segment) return;

            console.log('Processing audio segment for frame/chunk:', data.frame_number || data.chunk_number);

            try {
                // ÂàùÂßãÂåñÈü≥È¢ë‰∏ä‰∏ãÊñáÔºàÂ¶ÇÊûúËøòÊ≤°ÊúâÔºâ
                if (!audioContext) {
                    initializeAudioContext();
                }

                // Ëß£Á†Åbase64Èü≥È¢ëÊï∞ÊçÆ
                const audioData = base64ToArrayBuffer(data.audio_segment);

                // ËÆ∞ÂΩïÈòüÂàóÊ∑ªÂä†ÂâçÁöÑÈïøÂ∫¶
                const queueLengthBefore = audioQueue.length;

                // Â∞ÜÈü≥È¢ëÁâáÊÆµÊ∑ªÂä†Âà∞ÈòüÂàó
                audioQueue.push({
                    data: audioData,
                    startTime: data.audio_start_time || 0,
                    duration: data.audio_duration || 0.0625, // ÈªòËÆ§62.5msÔºà16fpsÔºâ
                    frameNumber: data.frame_number || data.chunk_number
                });

                console.log(`Audio segment added to queue. Queue length: ${queueLengthBefore} -> ${audioQueue.length}`);

                // Â¶ÇÊûúËøòÊ≤°ÊúâÂºÄÂßãÊí≠ÊîæÈü≥È¢ëÔºåÂºÄÂßãÊí≠Êîæ
                if (!isAudioPlaying) {
                    startAudioPlayback();
                } else if (queueLengthBefore === 0 && audioQueue.length === 1) {
                    // Â¶ÇÊûúÈü≥È¢ëÊ≠£Âú®Êí≠Êîæ‰ΩÜÈòüÂàó‰πãÂâçÊòØÁ©∫ÁöÑÔºåÁé∞Âú®ÊúâÊñ∞segment‰∫ÜÔºåÁªßÁª≠Â§ÑÁêÜÈòüÂàó
                    console.log('Queue was empty, resuming audio processing');
                    processAudioQueue();
                }

            } catch (error) {
                console.error('Error processing audio segment:', error);
            }
        }

        // Êñ∞Â¢ûÔºöÂàùÂßãÂåñÈü≥È¢ë‰∏ä‰∏ãÊñá
        function initializeAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // ÂàõÂª∫Èü≥ÈáèÊéßÂà∂ËäÇÁÇπ
                audioGainNode = audioContext.createGain();
                audioGainNode.connect(audioContext.destination);
                audioGainNode.gain.value = audioVolume;

                // Resume audio context (required for Safari/Mac)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                    }).catch(err => {
                        console.error('Failed to resume audio context:', err);
                    });
                }

                console.log('Audio context initialized, state:', audioContext.state);

                // ÊòæÁ§∫Èü≥È¢ëÊéßÂà∂Èù¢Êùø
                document.getElementById('audioControlsPanel').style.display = 'block';
                updateAudioControlStatus('Èü≥È¢ëÁ≥ªÁªüÂ∑≤ÂàùÂßãÂåñ');

            } catch (error) {
                console.error('Failed to initialize audio context:', error);
                updateAudioControlStatus('Èü≥È¢ëÂàùÂßãÂåñÂ§±Ë¥•');
            }
        }

        // Êñ∞Â¢ûÔºöÂºÄÂßãÈü≥È¢ëÊí≠Êîæ
        function startAudioPlayback() {
            if (!audioContext || audioQueue.length === 0) return;

            // Ensure audio context is running (critical for Safari/Mac)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Audio context resumed before playback');
                    startPlayback();
                }).catch(err => {
                    console.error('Failed to resume audio context before playback:', err);
                });
            } else {
                startPlayback();
            }

            function startPlayback() {
                isAudioPlaying = true;
                audioStartTime = audioContext.currentTime;
                // Initialize next audio time with a small buffer to prevent clicks
                nextAudioTime = audioContext.currentTime + 0.05;  // 50ms buffer
                console.log('Starting audio playback, context state:', audioContext.state, 'nextAudioTime:', nextAudioTime);

                // Êõ¥Êñ∞Èü≥È¢ëÁä∂ÊÄÅÊòæÁ§∫
                updateAudioStatus('üîä Èü≥È¢ë: Ê≠£Âú®Êí≠Êîæ');

                // Â§ÑÁêÜÈü≥È¢ëÈòüÂàó
                processAudioQueue();
            }
        }

        // Êñ∞Â¢ûÔºöÂ§ÑÁêÜÈü≥È¢ëÈòüÂàó
        function processAudioQueue() {
            if (!isAudioPlaying) {
                console.log('processAudioQueue: Not playing, returning');
                return;
            }
            if (audioQueue.length === 0) {
                console.log('processAudioQueue: Queue empty, waiting for more segments');
                return;
            }

            const audioSegment = audioQueue.shift();
            console.log(`Processing audio segment from queue. Remaining in queue: ${audioQueue.length}`);
            
            // Ëß£Á†ÅÈü≥È¢ëÊï∞ÊçÆ
            console.log(`Decoding audio segment for frame ${audioSegment.frameNumber}, data size: ${audioSegment.data.byteLength} bytes, context state: ${audioContext.state}`);

            audioContext.decodeAudioData(audioSegment.data.slice())
                .then(audioBuffer => {
                    console.log(`Audio decoded successfully: ${audioBuffer.duration}s, ${audioBuffer.numberOfChannels} channels, ${audioBuffer.sampleRate}Hz`);

                    // ÂàõÂª∫Èü≥È¢ëÊ∫ê
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioGainNode); // ËøûÊé•Âà∞Èü≥ÈáèÊéßÂà∂ËäÇÁÇπ

                    // Low-latency streaming: schedule immediately or at nextAudioTime
                    const currentTime = audioContext.currentTime;

                    // If nextAudioTime is in the past, play immediately with tiny buffer
                    let scheduledTime;
                    if (nextAudioTime <= currentTime) {
                        scheduledTime = currentTime + 0.01;  // 10ms buffer for immediate playback
                        console.warn(`Audio segment ${audioSegment.frameNumber} is late, playing immediately`);
                    } else {
                        scheduledTime = nextAudioTime;
                    }

                    const delay = scheduledTime - currentTime;
                    console.log(`Playing audio segment for frame ${audioSegment.frameNumber}, scheduled at: ${scheduledTime.toFixed(3)}s, delay: ${delay.toFixed(3)}s, volume: ${audioGainNode.gain.value}`);

                    // Êí≠ÊîæÈü≥È¢ë
                    source.start(scheduledTime);
                    currentAudioSource = source;

                    // Update nextAudioTime for the next segment
                    nextAudioTime = scheduledTime + audioBuffer.duration;
                    console.log(`Next audio segment will be scheduled at: ${nextAudioTime.toFixed(3)}s`);

                    // ËÆæÁΩÆÁªìÊùüÂõûË∞É
                    source.onended = () => {
                        // ÁªßÁª≠Â§ÑÁêÜ‰∏ã‰∏Ä‰∏™Èü≥È¢ëÁâáÊÆµ
                        setTimeout(() => {
                            processAudioQueue();
                        }, 10);
                    };
                })
                .catch(error => {
                    console.error('Error decoding audio data:', error);
                    console.error('Audio segment details:', {
                        frameNumber: audioSegment.frameNumber,
                        dataSize: audioSegment.data.byteLength,
                        contextState: audioContext.state
                    });
                    // ÁªßÁª≠Â§ÑÁêÜ‰∏ã‰∏Ä‰∏™Èü≥È¢ëÁâáÊÆµ
                    setTimeout(() => {
                        processAudioQueue();
                    }, 10);
                });
        }

        // Êñ∞Â¢ûÔºöÂÅúÊ≠¢Èü≥È¢ëÊí≠Êîæ
        function stopAudioPlayback() {
            isAudioPlaying = false;
            audioQueue = [];
            nextAudioTime = 0;  // Reset timing

            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                } catch (e) {
                    // ÂøΩÁï•Â∑≤ÁªèÂÅúÊ≠¢ÁöÑÈü≥È¢ëÊ∫êÈîôËØØ
                }
                currentAudioSource = null;
            }

            // Êõ¥Êñ∞Èü≥È¢ëÁä∂ÊÄÅÊòæÁ§∫
            updateAudioStatus('üîä Èü≥È¢ë: Â∑≤ÂÅúÊ≠¢');

            console.log('Audio playback stopped');
        }

        // Êñ∞Â¢ûÔºöÊõ¥Êñ∞Èü≥È¢ëÁä∂ÊÄÅÊòæÁ§∫
        function updateAudioStatus(status) {
            const audioInfo = document.getElementById('audioInfo');
            if (audioInfo) {
                audioInfo.textContent = status;
            }
        }

        // Êñ∞Â¢ûÔºöBase64ËΩ¨ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Èü≥È¢ëÊéßÂà∂ÂáΩÊï∞
        function toggleMute() {
            if (!audioGainNode) return;
            
            isMuted = !isMuted;
            const muteBtn = document.getElementById('muteBtn');
            
            if (isMuted) {
                audioGainNode.gain.value = 0;
                muteBtn.textContent = 'üîä ÂèñÊ∂àÈùôÈü≥';
                updateAudioControlStatus('Èü≥È¢ëÂ∑≤ÈùôÈü≥');
            } else {
                audioGainNode.gain.value = audioVolume;
                muteBtn.textContent = 'üîá ÈùôÈü≥';
                updateAudioControlStatus('Èü≥È¢ëÂ∑≤ÊÅ¢Â§ç');
            }
        }

        function updateVolume() {
            const slider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            
            audioVolume = slider.value / 100;
            volumeValue.textContent = slider.value + '%';
            
            if (audioGainNode && !isMuted) {
                audioGainNode.gain.value = audioVolume;
            }
            
            updateAudioControlStatus(`Èü≥ÈáèËÆæÁΩÆ‰∏∫ ${slider.value}%`);
        }

        function resetAudio() {
            // ÂÅúÊ≠¢ÂΩìÂâçÈü≥È¢ëÊí≠Êîæ
            stopAudioPlayback();

            // ÈáçÁΩÆÈü≥È¢ëÈòüÂàó
            audioQueue = [];

            // ÈáçÁΩÆÈü≥È¢ëÁä∂ÊÄÅ
            isAudioPlaying = false;
            nextAudioTime = 0;

            updateAudioControlStatus('Èü≥È¢ëÂ∑≤ÈáçÁΩÆ');
            updateAudioStatus('üîä Èü≥È¢ë: Â∑≤ÈáçÁΩÆ');
        }

        function updateAudioControlStatus(message) {
            const status = document.getElementById('audioStatus');
            if (status) {
                status.textContent = message;
            }
        }

        // ÂºÄÂßãÊµÅÂºèÊí≠Êîæ
        function startStreamingPlayback() {
            if (!canvas) {
                canvas = document.getElementById('streamingCanvas');
                ctx = canvas.getContext('2d');
                // Don't set size here - let first frame determine dimensions
                canvasSizeSet = false;
            }

            isPlaying = true;
            canvas.style.display = 'block';
            document.getElementById('videoPlaceholder').style.display = 'none';
            document.getElementById('streamingInfo').style.display = 'block';

            // Á°Æ‰øùÈü≥È¢ëÊéßÂà∂Èù¢ÊùøÊòæÁ§∫
            if (audioContext) {
                document.getElementById('audioControlsPanel').style.display = 'block';
            }

            // ÂºÄÂßãÊí≠ÊîæÂæ™ÁéØ
            playNextFrame();
        }

        // Êí≠Êîæ‰∏ã‰∏ÄÂ∏ß
        function playNextFrame() {
            console.log('playNextFrame called. Queue length:', frameQueue.length, 'isPlaying:', isPlaying);

            if (frameQueue.length > 0 && isPlaying) {
                const frameData = frameQueue.shift();
                console.log('Playing frame:', frameData.frame_number);

                // ÂàõÂª∫ÂõæÂÉèÂØπË±°
                const img = new Image();
                img.onload = function() {
                    console.log('Image loaded successfully for frame:', frameData.frame_number, 'Dimensions:', img.width, 'x', img.height);

                    // Set canvas size based on first frame's actual dimensions
                    if (!canvasSizeSet) {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        // Also set CSS dimensions to match intrinsic size
                        canvas.style.width = img.width + 'px';
                        canvas.style.height = img.height + 'px';
                        videoWidth = img.width;
                        videoHeight = img.height;
                        canvasSizeSet = true;
                        console.log('Canvas size set to:', canvas.width, 'x', canvas.height);
                    }

                    // Store the first frame to display at the end
                    if (frameData.frame_number === 1 || !firstFrameImage) {
                        firstFrameImage = img;
                        console.log('First frame saved for end display');
                    }

                    // ÁªòÂà∂Âà∞canvas - use actual image dimensions to avoid distortion
                    ctx.drawImage(img, 0, 0);

                    // ÁªßÁª≠Êí≠Êîæ‰∏ã‰∏ÄÂ∏ß
                    // setTimeout(playNextFrame, 40); // 25fps
                    setTimeout(playNextFrame, 1000 / 16);   // 16 fps
                };

                img.onerror = function() {
                    console.error('ÂõæÂÉèÂä†ËΩΩÂ§±Ë¥•:', frameData);
                    // ÁªßÁª≠Êí≠Êîæ‰∏ã‰∏ÄÂ∏ß
                    setTimeout(playNextFrame, 40);
                    setTimeout(playNextFrame, 1000 / 16);
                };

                // ËÆæÁΩÆÂõæÂÉèÊ∫ê
                if (frameData.frame_data) {
                    console.log('Setting image source for frame:', frameData.frame_number);
                    img.src = 'data:image/jpeg;base64,' + frameData.frame_data;
                } else {
                    console.error('Â∏ßÊï∞ÊçÆÁº∫Â§±:', frameData);
                    setTimeout(playNextFrame, 40);
                }
            } else if (isPlaying) {
                // ÈòüÂàó‰∏∫Á©∫ÔºåÁ≠âÂæÖÊõ¥Â§öÂ∏ß
                console.log('Frame queue empty, waiting for more frames...');
                setTimeout(playNextFrame, 100);
            } else {
                console.log('Not playing or no frames in queue');
            }
        }

        // Êõ¥Êñ∞ÊµÅÂºè‰ø°ÊÅØ
        function updateStreamingInfo(data) {
            document.getElementById('frameInfo').textContent = `Â∏ßÊï∞: ${data.frame_number} / ${data.total_frames || 'Unknown'}`;
            document.getElementById('chunkInfo').textContent = `Chunk: ${data.chunk_number + 1} / ${data.total_chunks || 'Unknown'}`;
            document.getElementById('progressInfo').textContent = `ËøõÂ∫¶: ${Math.round(data.progress || 0)}%`;
            
            // Êõ¥Êñ∞ËøõÂ∫¶Êù°
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            if (data.progress !== undefined) {
                progressFill.style.width = data.progress + '%';
                progressText.textContent = `ÁîüÊàê‰∏≠... ${Math.round(data.progress)}%`;
            }
        }

        // Êõ¥Êñ∞ËøõÂ∫¶
        function updateProgress(data) {
            if (data.session_id === currentSessionId) {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                progressFill.style.width = data.progress + '%';
                progressText.textContent = `ÁîüÊàê‰∏≠... ${Math.round(data.progress)}%`;
            }
        }

        // Â§ÑÁêÜÁîüÊàêÂÆåÊàê
        function handleGenerationComplete(data) {
            if (data.session_id === currentSessionId) {
                console.log('Generation complete, finishing video stream...');
                updateStatus('ÁîüÊàêÂÆåÊàêÔºÅ', false);
                
                // Á≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥ËÆ©Ââ©‰ΩôÂ∏ßÊí≠ÊîæÂÆåÊàê
                setTimeout(() => {
                    finishGeneration();
                }, 2000);
            }
        }

        // Êñ∞Â¢ûÔºöÂÆåÊàêÁîüÊàêÁöÑÊ∏ÖÁêÜÂ∑•‰Ωú
        function finishGeneration() {
            console.log('Finishing generation and cleaning up...');
            isGenerating = false;
            isPlaying = false;
            canvasSizeSet = false;  // Reset for next generation

            // ÂÅúÊ≠¢Èü≥È¢ëÊí≠Êîæ
            stopAudioPlayback();

            showMessage('ËßÜÈ¢ëÁîüÊàêÂÆåÊàêÔºÅÈü≥È¢ëÂ∑≤ÂêåÊ≠•Êí≠Êîæ', 'success');
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('streamingInfo').style.display = 'none';

            // ÈöêËóèÈü≥È¢ëÊéßÂà∂Èù¢Êùø
            setTimeout(() => {
                document.getElementById('audioControlsPanel').style.display = 'none';
            }, 3000); // 3ÁßíÂêéÈöêËóè

            // ÈáçÁΩÆUI
            currentSessionId = null;
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('generateBtn').textContent = 'üöÄ ÂºÄÂßãÊµÅÂºèÁîüÊàê';

            // Display the first frame of the generated video instead of reference
            const videoPlayer = document.getElementById('videoPlayer');
            const streamingCanvas = document.getElementById('streamingCanvas');
            const videoPlaceholder = document.getElementById('videoPlaceholder');

            // Hide video player and placeholder
            videoPlayer.style.display = 'none';
            videoPlaceholder.style.display = 'none';

            // Draw the first frame on the canvas and keep it visible
            streamingCanvas.style.display = 'block';
            if (firstFrameImage && ctx) {
                ctx.drawImage(firstFrameImage, 0, 0);
                console.log(`Displaying first frame of generated video at ${videoWidth}x${videoHeight} resolution`);
            } else {
                console.log('No first frame available, keeping current canvas content');
            }
        }

        // Â§ÑÁêÜÁîüÊàêÈîôËØØ
        function handleGenerationError(data) {
            if (data.session_id === currentSessionId) {
                isGenerating = false;
                isPlaying = false;
                canvasSizeSet = false;  // Reset for next generation

                // ÂÅúÊ≠¢Èü≥È¢ëÊí≠Êîæ
                stopAudioPlayback();

                showMessage('ÁîüÊàêÂ§±Ë¥•: ' + data.error, 'error');
                updateStatus('ÁîüÊàêÂ§±Ë¥•', false);

                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('streamingInfo').style.display = 'none';
                currentSessionId = null;
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('generateBtn').textContent = 'üöÄ ÂºÄÂßãÊµÅÂºèÁîüÊàê';

                // Display first frame if available, otherwise show placeholder
                const streamingCanvas = document.getElementById('streamingCanvas');
                const videoPlaceholder = document.getElementById('videoPlaceholder');

                if (firstFrameImage && ctx) {
                    // If we captured the first frame, display it
                    streamingCanvas.style.display = 'block';
                    videoPlaceholder.style.display = 'none';
                    ctx.drawImage(firstFrameImage, 0, 0);
                    console.log('Error occurred - displaying first frame of generated video');
                } else if (canvasSizeSet) {
                    // If canvas was set up but no first frame, keep current content
                    streamingCanvas.style.display = 'block';
                    videoPlaceholder.style.display = 'none';
                } else {
                    // If no frames were rendered yet, show the placeholder
                    streamingCanvas.style.display = 'none';
                    videoPlaceholder.innerHTML = '<span style="color: #6c757d; font-size: 1.2em;">üé• ÊµÅÂºèÁîüÊàêÁöÑËßÜÈ¢ëÂ∞ÜÂú®ËøôÈáåÂÆûÊó∂ÊòæÁ§∫</span>';
                    videoPlaceholder.style.display = 'block';
                }
            }
        }

        // ÊòæÁ§∫ÊúÄÁªàËßÜÈ¢ë
        function displayFinalVideo(outputPath) {
            const videoPlayer = document.getElementById('videoPlayer');
            const canvas = document.getElementById('streamingCanvas');
            const placeholder = document.getElementById('videoPlaceholder');
            const streamingInfo = document.getElementById('streamingInfo');
            
            // ÈöêËóècanvasÂíå‰ø°ÊÅØ
            canvas.style.display = 'none';
            streamingInfo.style.display = 'none';
            
            // ÊòæÁ§∫ËßÜÈ¢ëÊí≠ÊîæÂô®
            videoPlayer.style.display = 'block';
            placeholder.style.display = 'none';
            
            // ËÆæÁΩÆËßÜÈ¢ëÊ∫êÔºàËøôÈáåÈúÄË¶Å‰ªéÊúçÂä°Âô®Ëé∑ÂèñËßÜÈ¢ëÊñá‰ª∂Ôºâ
            // Áî±‰∫éÊòØÊú¨Âú∞Êñá‰ª∂ÔºåÊàë‰ª¨ÂèØËÉΩÈúÄË¶ÅÂàõÂª∫‰∏Ä‰∏™‰∏ãËΩΩÈìæÊé•
            videoPlayer.src = `/download_video?path=${encodeURIComponent(outputPath)}`;
            
            // Ëá™Âä®Êí≠Êîæ
            videoPlayer.play().catch(e => console.log('Ëá™Âä®Êí≠ÊîæÂ§±Ë¥•:', e));
        }

        // ÂΩïÈü≥ÂäüËÉΩ
        document.getElementById('recordBtn').addEventListener('click', toggleRecording);

        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }

        async function startRecording() {
            try {
                // Request audio with higher quality settings
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,  // Mono audio
                        sampleRate: 24000,  // Higher sample rate for better quality
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Try to use a high-quality audio format
                let options = { mimeType: 'audio/webm;codecs=opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    console.log('audio/webm;codecs=opus not supported, trying audio/webm');
                    options = { mimeType: 'audio/webm' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        console.log('audio/webm not supported, using default');
                        options = {};
                    }
                }

                mediaRecorder = new MediaRecorder(stream, options);
                audioChunks = [];
                recordingStartTime = Date.now();

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log('Audio chunk received:', event.data.size, 'bytes');
                    }
                };

                mediaRecorder.onstop = () => {
                    const mimeType = mediaRecorder.mimeType || 'audio/webm';
                    audioBlob = new Blob(audioChunks, { type: mimeType });
                    const durationSec = ((Date.now() - recordingStartTime) / 1000).toFixed(1);
                    const sizeMB = (audioBlob.size / 1024 / 1024).toFixed(2);
                    updateAudioStatus(`ÂΩïÈü≥ÂÆåÊàêÔºÅÊó∂Èïø: ${durationSec}Áßí, Â§ßÂ∞è: ${sizeMB}MB, Ê†ºÂºè: ${mimeType}`);
                    console.log('Recording complete:', {
                        duration: durationSec + 's',
                        size: audioBlob.size + ' bytes',
                        type: mimeType
                    });
                    checkReadyState();
                };

                // Request data every 100ms to ensure chunks are collected
                mediaRecorder.start(100);
                isRecording = true;
                updateRecordButton(true);
                updateAudioStatus('Ê≠£Âú®ÂΩïÈü≥...');
                console.log('Recording started with mime type:', mediaRecorder.mimeType);
            } catch (error) {
                console.error('ÂΩïÈü≥Â§±Ë¥•:', error);
                updateAudioStatus('ÂΩïÈü≥Â§±Ë¥•: ' + error.message);
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                updateRecordButton(false);
            }
        }

        function updateRecordButton(recording) {
            const btn = document.getElementById('recordBtn');
            const icon = document.getElementById('recordIcon');
            const text = document.getElementById('recordText');

            if (recording) {
                btn.classList.add('recording');
                icon.textContent = '‚èπÔ∏è';
                text.textContent = 'ÂÅúÊ≠¢ÂΩïÈü≥';
            } else {
                btn.classList.remove('recording');
                icon.textContent = 'üéôÔ∏è';
                text.textContent = 'ÂºÄÂßãÂΩïÈü≥';
            }
        }

        function updateAudioStatus(message) {
            document.getElementById('audioStatus').textContent = message;
        }

        // Èü≥È¢ëÊñá‰ª∂‰∏ä‰º†
        function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (file) {
                audioBlob = file;
                updateAudioStatus('Èü≥È¢ëÊñá‰ª∂Â∑≤‰∏ä‰º†: ' + file.name);
                checkReadyState();
            }
        }

        // ÂõæÁâáÊñá‰ª∂‰∏ä‰º†
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                imageFile = file;
                
                // ÊòæÁ§∫È¢ÑËßà
                const reader = new FileReader();
                reader.onload = function(e) {
                    const preview = document.getElementById('previewImage');
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                };
                reader.readAsDataURL(file);
                
                checkReadyState();
            }
        }

        // Ê£ÄÊü•ÊòØÂê¶ÂáÜÂ§áÂ•ΩÁîüÊàê
        function checkReadyState() {
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = !(audioBlob && imageFile);
        }

        // ÁîüÊàêËßÜÈ¢ë
        async function generateVideo() {
            if (!audioBlob || !imageFile) {
                showMessage('ËØ∑ÂÖàÈÄâÊã©Èü≥È¢ëÂíåÂõæÁâáÊñá‰ª∂', 'error');
                return;
            }

            if (isGenerating) {
                return;
            }

            // ÈáçÁΩÆÁä∂ÊÄÅ
            frameQueue = [];
            videoChunks = [];
            isPlaying = false;
            canvasSizeSet = false;  // Reset canvas sizing
            videoWidth = 720;  // Reset to default
            videoHeight = 720;  // Reset to default
            isGenerating = true;
            isVideoMode = false; // ÈªòËÆ§‰ΩøÁî®ÈÄêÂ∏ßÊ®°Âºè
            isStreamFinished = false;
            isMSEInitialized = false;
            firstFrameImage = null;  // Reset first frame for new generation

            // ÈáçÁΩÆÈü≥È¢ëÁä∂ÊÄÅ
            stopAudioPlayback();
            audioQueue = [];
            isAudioPlaying = false;

            // Ê∏ÖÁêÜMediaSourceÁõ∏ÂÖ≥ËµÑÊ∫ê
            if (mediaSource && mediaSource.readyState === 'open') {
                try {
                    mediaSource.endOfStream();
                } catch (e) {
                    console.error("Error ending previous stream:", e);
                }
            }
            mediaSource = null;
            sourceBuffer = null;

            // ÊòæÁ§∫ËøõÂ∫¶Êù°
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('generateBtn').textContent = 'üîÑ ÁîüÊàê‰∏≠...';
            updateStatus('Ê≠£Âú®ÂàùÂßãÂåñÁîüÊàê...', true);

            try {
                // Ê£ÄÊü•socketËøûÊé•Áä∂ÊÄÅ
                console.log('[DEBUG] Socket connected:', socket && socket.connected);
                if (!socket || !socket.connected) {
                    throw new Error('WebSocket not connected. Please refresh the page.');
                }

                // ËΩ¨Êç¢Èü≥È¢ë‰∏∫base64
                console.log('[DEBUG] Converting audio to base64...');
                const audioBase64 = await blobToBase64(audioBlob);
                console.log('[DEBUG] Audio base64 length:', audioBase64 ? audioBase64.length : 0);
                console.log('[DEBUG] Audio MIME type:', audioBlob ? audioBlob.type : 'unknown');

                // ËΩ¨Êç¢ÂõæÁâá‰∏∫base64
                console.log('[DEBUG] Converting image to base64...');
                const imageBase64 = await fileToBase64(imageFile);
                console.log('[DEBUG] Image base64 length:', imageBase64 ? imageBase64.length : 0);

                // ÈÄöËøáWebSocketÂèëÈÄÅÂà∞ÊúçÂä°Âô®
                const requestData = {
                    audio_base64: audioBase64,
                    audio_mime_type: audioBlob ? audioBlob.type : 'audio/wav',
                    image_base64: imageBase64
                };

                // ÂèëÈÄÅÁîüÊàêËØ∑Ê±Ç
                console.log('[DEBUG] Sending generate_streaming_base64 request...');
                socket.emit('generate_streaming_base64', requestData);
                console.log('[DEBUG] Request sent!');

                // Á≠âÂæÖÊúçÂä°Âô®ÂìçÂ∫î
                let generationStarted = false;
                const startPromise = new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Generation start timeout'));
                    }, 20000);

                    socket.once('generation_started', (data) => {
                        clearTimeout(timeout);
                        currentSessionId = data.session_id;
                        // Join the session room to receive events
                        socket.emit('join_session', { session_id: data.session_id });
                        generationStarted = true;
                        resolve(data);
                    });

                    socket.once('error', (data) => {
                        clearTimeout(timeout);
                        reject(new Error(data.message || 'Generation failed'));
                    });
                });

                const result = await startPromise;

                showMessage('ÂºÄÂßãÊµÅÂºèÁîüÊàêËßÜÈ¢ëÔºÅ', 'success');
                updateStatus('Ê≠£Âú®ÊµÅÂºèÁîüÊàêËßÜÈ¢ë...', true);

            } catch (error) {
                console.error('ÁîüÊàêËßÜÈ¢ëÂ§±Ë¥•:', error);
                showMessage('ÁîüÊàêËßÜÈ¢ëÂ§±Ë¥•: ' + error.message, 'error');
                updateStatus('ÁîüÊàêÂ§±Ë¥•', false);
                isGenerating = false;
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('generateBtn').textContent = 'üöÄ ÂºÄÂßãÊµÅÂºèÁîüÊàê';
                document.getElementById('progressContainer').style.display = 'none';
            }
        }

        // ËæÖÂä©ÂáΩÊï∞
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function updateStatus(message, loading = false) {
            const status = document.getElementById('status');
            status.innerHTML = loading ? `<span class="loading"></span>${message}` : message;
        }

        function showMessage(message, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = message;
            messageDiv.className = type;
            messageDiv.style.display = 'block';
            
            // 3ÁßíÂêéËá™Âä®ÈöêËóè
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 3000);
        }

        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÁöÑÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            // ÂàùÂßãÂåñWebSocket
            initializeWebSocket();
            
            // Ê£ÄÊü•ÊúçÂä°Âô®Áä∂ÊÄÅ
            checkServerHealth();
        });

        async function checkServerHealth() {
            try {
                const response = await fetch(`${serverUrl}/health`);
                if (response.ok) {
                    console.log('ÊúçÂä°Âô®ËøûÊé•Ê≠£Â∏∏');
                } else {
                    showMessage('ÊúçÂä°Âô®ËøûÊé•ÂºÇÂ∏∏', 'error');
                }
            } catch (error) {
                showMessage('Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®ÔºåËØ∑Á°Æ‰øùÊúçÂä°Âô®Â∑≤ÂêØÂä®', 'error');
            }
        }
    </script>
</body>
</html> 